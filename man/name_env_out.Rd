% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/name_env_out.R
\name{name_env_out}
\alias{name_env_out}
\title{Create and/or parse output directory paths}
\usage{
name_env_out(
  set_list,
  base_dir = NULL,
  show_null = FALSE,
  return_contexts = TRUE,
  dir_with_context = FALSE,
  all_files = FALSE,
  search_dir = if (is.null(base_dir)) here::here() else NULL,
  reg_exp = NULL,
  remove_dots = TRUE,
  ...
)
}
\arguments{
\item{set_list}{Nested list, with two levels, of critical settings (only) for
use in output path names. The first elements of the list will return
directories. Elements within each of the first elements of the list are
concatenated to form the name of each directory (see examples).}

\item{base_dir}{Character. Directory prefix to the output path.}

\item{show_null}{Logical. Display "NULL" or "NA" in names
(or gsub it out with "").}

\item{return_contexts}{Logical. If TRUE (default) contexts, directories and
path are returned, otherwise just directories and path.}

\item{dir_with_context}{Logical. If FALSE (default) the first elements in
\code{set_list} are used as prefix to each context, otherwise no prefix is added.
Set to TRUE if there are contexts repeated across any elements of
\code{set_list}.}

\item{all_files}{Logical or numeric. Return files within the \code{path} column
provided in the resulting dataframe? If numeric, passed to the \code{recurse}
argument of \code{fs::dir_ls()}.}

\item{search_dir}{Character. Path(s) to search for the \code{path} in the returned
tibble. Ignored unless \code{base_dir} is null. Allows for searching several
different paths for the same \code{path} in the returned tibble.}

\item{reg_exp}{Character. Combined with \code{path} in the returned tibble to
search for files.}

\item{remove_dots}{Logical. Should \code{.} be removed from elements within the
list? e.g. \code{0.95} becomes \code{095}}

\item{...}{Passed to \code{fs::dir_ls()}. Arguments \code{path} and \code{regexp} are
already provided, so providing them here will cause an error.}
}
\value{
Tibble containing:
\itemize{
\item all contexts: named as per the second level elements of \code{set_list}
\item directories: a directory for each element in the first level of \code{set_list}
\item path: the output path, prepended with base_dir
}
}
\description{
Either create directory path for saving outputs or parse the meta data from
an output directory path. The first elements in the list will form
directories. The second elements in the list form the name of each directory,
separated by "__".
}
\examples{

# a list of settings_temp
settings_temp <- list(extent = list(polygons = "sa_ibrasub_xn"
                               , filt_col = NULL
                               , filt_level = NULL
                               , buffer = 0
                               , temp_ext = "P50Y"
                               )
                 , grain = list(x = 90
                                , y = 90
                                , z = "P50Y"
                                , taxonomic = "species"
                                )
                 , reliability = list(rel_geo = 10000
                                      , rel_temp = "P10Y"
                                      )
                 , aoi = list(polygons = "lsa"
                              , filt_col = "LSA"
                              , filt_level = "GA"
                              , buffer = 0
                              )
                 )

# generate an 'out directory' based on those settings_temp
settings_temp$out_dir <- name_env_out(set_list = settings_temp#[1:4]
                                 , base_dir = here::here("inst", "examples")
                                 , dir_with_context = TRUE
                                 )$path

settings_temp$out_dir

# create the 'out directory'
fs::dir_create(settings_temp$out_dir)

# put some junk files in the 'out directory'
purrr::map(1:10
           , \(x) tempfile(tmpdir = settings_temp$out_dir)
           ) \%>\%
  fs::file_create()

# use name_env_out to return the list of files, based on the settings_temp
files <- name_env_out(set_list = settings_temp[1:4]
                      , base_dir = here::here("inst", "examples")
                      , dir_with_context = TRUE
                      , all_files = TRUE
                      # dots
                      , recurse = TRUE
                      ) \%>\%
  tidyr::unnest(cols = c(files)
                , keep_empty = TRUE
                )

files

# clean up
fs::dir_delete(settings_temp$out_dir) # only run this if you're sure it is safe
rm(settings_temp, files)


}
