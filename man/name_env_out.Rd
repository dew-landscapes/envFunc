% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/name_env_out.R
\name{name_env_out}
\alias{name_env_out}
\title{Name, create, parse and/or search output directories}
\usage{
name_env_out(
  env_out,
  base_dir = NULL,
  dir_with_context = FALSE,
  all_files = FALSE,
  search_dir = if (is.null(base_dir)) here::here() else NULL,
  remove_stop = TRUE,
  ret = if (all_files) "df" else "path",
  create_path = ret == "path",
  ...
)
}
\arguments{
\item{env_out}{Nested list, with two levels, of critical settings (only) for
use in output path names. The first elements of the list will return
directories. Elements within each of the first elements of the list are
concatenated to form the name of each directory (see examples).}

\item{base_dir}{Character. Directory prefix to the output path.}

\item{dir_with_context}{Logical. If FALSE (default) the first elements in
\code{env_out} are used as prefix to each context, otherwise no prefix is added.
Set to TRUE if there are contexts repeated across any elements of
\code{env_out}.}

\item{all_files}{Logical or numeric. Return files within the \code{path} column
provided in the resulting dataframe? If numeric, passed to the \code{recurse}
argument of \code{fs::dir_ls()}.}

\item{search_dir}{Character. Path(s) to search for the \code{path} in the returned
tibble. Ignored unless \code{base_dir} is null. Allows for searching several
different paths for the same \code{path} in the returned tibble.}

\item{remove_stop}{Logical. Should \code{.} be removed from elements within the
list? e.g. \code{0.95} becomes \code{095}}

\item{ret}{Character. Return a dataframe (\code{"df"}) or path (\code{"path"})?}

\item{create_path}{Logical. If \code{TRUE} the path is created via
\code{fs::dir_create()}. This is independent of \code{ret == "path"}.}

\item{...}{Passed to \code{fs::dir_ls()}. Argument \code{path} is already provided, so
providing here will cause an error.}
}
\value{
If \code{ret == "df"}, tibble containing:
\itemize{
\item all contexts: named as per the second level elements of \code{env_out}
\item directories: a directory for each element in the first level of \code{env_out}
\item path: the output path, prefixed with \code{base_dir}
}

If \code{ret == "path"} a path.

If \code{create_path} the path is created via \code{fs::dir_create()}.
}
\description{
Name, create, parse and/or search output directories
}
\examples{

# a list of settings_temp
settings_temp <- list(extent = list(polygons = "sa_ibrasub_xn"
                               , filt_col = NULL
                               , filt_level = NULL
                               , buffer = 0
                               , temp_ext = "P50Y"
                               )
                 , grain = list(x = 90
                                , y = 90
                                , z = "P50Y"
                                , taxonomic = "species"
                                )
                 , reliability = list(rel_geo = 10000
                                      , rel_temp = "P10Y"
                                      )
                 , aoi = list(polygons = "lsa"
                              , filt_col = "LSA"
                              , filt_level = "GA"
                              , buffer = 0
                              )
                 )

# generate an 'out directory' based on those settings_temp
settings_temp$out_dir <- name_env_out(set_list = settings_temp#[1:4]
                                 , base_dir = here::here("inst", "examples")
                                 , dir_with_context = TRUE
                                 )$path

settings_temp$out_dir

# create the 'out directory'
fs::dir_create(settings_temp$out_dir)

# put some junk files in the 'out directory'
purrr::map(1:10
           , \(x) tempfile(tmpdir = settings_temp$out_dir)
           ) \%>\%
  fs::file_create()

# use name_env_out to return the list of files, based on the settings_temp
files <- name_env_out(set_list = settings_temp[1:4]
                      , base_dir = here::here("inst", "examples")
                      , dir_with_context = TRUE
                      , all_files = TRUE
                      # dots
                      , recurse = TRUE
                      ) \%>\%
  tidyr::unnest(cols = c(files)
                , keep_empty = TRUE
                )

files

# clean up
fs::dir_delete(settings_temp$out_dir) # only run this if you're sure it is safe
rm(settings_temp, files)


}
